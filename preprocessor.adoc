= 预处理器（Preprocessor）
:toc:
:toc-title: 目录
:numbered:


== 概念（Concept）

Red 预处理器是 Red 的一种方言，它允许使用一个在常规 Red 语言之上的特定的层来转换 Red 源码。转换是通过在 Red 源码中内联预处理器关键字（称为 `directives`（指令））达到的。这些指令被处理的时机为：

* 当 Red 源码被编译的时候
* 当 Red 源码通过传有一个文件参数的 `do` 函数被运行的时候
* 当 `expand-directives` 函数在区块值上被调用的时候
TODO：考量上句的翻译

预处理器在加载阶段之后被调用，所以它处理的是 Red 值而不是文本形式的源码。

指令类别：

* 条件指令：根据表达式的结果包含代码。
* 控制指令：控制预处理器的行为。
* 宏：使用函数转换代码，它允许更复杂的转换。

指令以特定的 `issue!` 值来表示（以一个 `#` 符号开头）。

当一个指令被处理的时候，它会被替换为它返回的结果值（有些指令没有返回值，所以它们仅会被移除），这就是达成源码的转换的方法。

NOTE: Red/System 有它自己的 http://static.red-lang.org/red-system-specs-light.html#section-16[预处理器]，是类似的，不过它是在底层，并且应用在的是文本形式的源码上。

=== 配置对象（Config object）

它在条件表达式与宏中提供了一个隐含的 `config` 对象，以给与用于编译源码的设定的访问，这些设定经常用于有条件地包含代码。全面的设定清单可以从 https://github.com/red/red/blob/master/system/compiler.r#L31[这里] 找到。

*例：*
    
    #if config/OS = 'Windows [#include %windows.red]

NOTE: 当在运行时（从 Red 的解释器）使用预处理器时，`config` 对象也有效，而且它会反映用来编译目前用来运行代码的该 Red 可执行文件的选项。

=== 执行语境（Execution context）

为了避免泄露单词到全局语境，造成多余的副作用，所有在指令中使用的表达式都绑定到一个专用的语境中。语境会随着用于条件表达式、宏和 `#do` 指令的每个设词扩展。

TIP:

* 可以使用以下表达式打印出隐藏的语境的内容：
        
        #do [probe self]
        
* 当在运行时被使用的时候，隐藏的语境也可以使用以下形式直接访问：
        
        probe preprocessor/exec

=== 实现的注解（Implementation note）

当前，用在编译时的指令中的表达式都是用 Rebol2 解释器执行的，因为它运行着工具链的代码。这是临时的，应会尽块地把它切换为一个 Red 执行器。在此期间要确保你的表达式和宏代码也可以用 Red 运行，以在运行时（未来还包含编译时）和 Red 解释器兼容。

== 宏（Macros）

Red 预处理器支持定义宏函数（简称 *macros*）来实现更复杂的转换。宏允许以高效的形式进行元编程，它执行的代价花费在编译时而不是运行时。在运行时 Red 已经有很强的元编程能力，不过为了使 Red 源码在编译器和解释器运行地一样好，宏也可以在运行时被解析。

NOTE: 没有读取时（读者）宏。考虑到用 Parse 方言对文本形式的源进行预处理已经是如此简单，这种支持现在是多余的。

预处理器支持两种类型的宏：

=== 命名宏（Named macros）

这种类型的宏是高级的，预处理器负责为用户获取参数和替换返回值。典型的形式是：

    #macro name: func [arg1 arg2... /local word1 word2...][...code...]
    
这样定义一个宏之后，源码中每个遇到 `name` 单词的地方，都会触发以下步骤：

. 获取参数值。
. 用参数调用宏函数。
. 用函数的最后一个值替换宏调用及其参数。
. 从替换了值的地方恢复预处理器（为了允许宏的递归执行）。

NOTE: 目前不支持指定参数类型。

*例：*

----
Red []
#macro make-KB: func [n][n * 1024]
print make-KB 64
----  

结果将为：

----
Red []
print 65536
----

从一个宏中调用其他宏：

----
Red []
#macro make-KB: func [n][n * 1024]
#macro make-MB: func [n][make-KB make-KB n]

print make-MB 1
----  

结果将为：

----  
Red []
print 1048576
----

=== 模式匹配宏（Pattern-matching macros）

这种类型的宏以 Parse 方言的规则或关键字来匹配一个模式，而不是匹配一个单词并获取参数。像命名宏一样，返回值被当作匹配到的模式的替换品。

不过，也有这种类型的宏的一个低级版本，它以 `[manual]` 属性触发。在这种情况下没有隐含的行为，而是给与用户完全的控制。自动替换不会发生，期望的转换的应用和处理的恢复点的设置都取决于宏函数。

模式匹配宏的典型形式为：

----
 #macro <rule> func [<attribute> start end /local word1 word2...][...code...]
----

`<rule>` 部分可以是：

* 一个 `lit-word!` 值：用来匹配一个特定的单词。
* 一个 `word!` 值：一个 Parse 关键字，比如一个数据类型的名字，或者用 `skip` 匹配 *所有* 的值。
* 一个 `block!` 值：一组 Parse 方言规则。

`start` 和 `end` 参数是在源码中界定匹配到的模式的引用。返回值需为一个对恢复位置的引用。

`<attribute>` 可以是 `[manual]`，它会触发宏的低级手动模式。

*例：*

----
Red []

#macro integer! func [s e][s/1 + 1]
print 1 + 2
----

结果将为：

----
Red []
print 2 + 3 
----

使用 *manual* 模式，同样的宏可以被写作：

----
Red []

#macro integer! func [[manual] s e][s/1: s/1 + 1 next s]
print 1 + 2
----
  
使用一个规则区块来创建一个可变参数函数：

----
Red []
#macro ['max some [integer!]] func [s e][
    first maximum-of copy/part next s e
]
print max 4 2 3 8 1
----

结果将为：

----
Red []
print 8 
----

== 指令（Directives）

=== #if 

*语法*

----
#if <expr> [<body>]

<expr> : 表达式，它的最后一个值会被用作一个条件.
<body> : 若 <expr> 为 true，将会被包含的代码.
----

*描述*

如果条件表达式为真，则包含一整个区块的代码。如果包含了 `<body>` 区块，它也将被传递给预处理器。

*例*

----
Red []

#if config/OS = 'Windows [print "OS is Windows"]
----

如果在 Windows 下运行，结果将为以下代码：

----
Red []

print "OS is Windows"
----

否则结果将仅为：

----
Red []
----

也可以使用 `#do` 指令定义你自己的单词，它可以用在之后的条件表达式当中：

----
Red []

#do [debug?: yes]

#if debug? [print "running in debug mode"]
----

结果将为：

----
Red []

print "running in debug mode"
----

=== #either 

*语法*

----
#either <expr> [<true>][<false>]

<expr>  : 表达式，它的最后一个值会被用作一个条件.
<true>  : 若 <expr> 为 true，将会被包含的代码.
<false> : 若 <expr> 为 false，将会被包含的代码.
----

*描述*

根据一个条件表达式选择要包含的一个代码区块，包含了的区块也会被传递给预处理器。

*例*

----
Red []

print #either config/OS = 'Windows ["Windows"]["Unix"]
----

如果在 Windows 下运行，结果将为以下代码：

----
Red []

print "Windows"
----

否则结果将为：

----
Red []

print "Unix"
----

=== #switch 

*语法*

----
#switch <expr> [<value1> [<case1>] <value2> [<case2>] ...]
#switch <expr> [<value1> [<case1>] <value2> [<case2>] ... #default [<default>]]

<valueN>  : 要匹配的值.
<caseN>   : 若最后一个测试过的值匹配，将会被包含的代码.
<default> : 若没有其他值是匹配的，将会被包含的代码.
----

*描述*

根据一个值在多个选择中选取要包含的一个代码区块，包含了的区块也会被传递给预处理器。

*例*

----
Red []

print #switch config/OS [
    Windows ["Windows"]
    Linux   ["Unix"]
    MacOSX  ["macOS"]
]
----   

如果在 Windows 下运行，结果将为：

----
Red []

print "Windows"
----

=== #case 

*语法*

----
#case [<expr1> [<case1>] <expr2> [<case2>] ...]

<exprN> : 条件表达式.
<caseN> : 若最后一个条件表达式为 true，将会被包含的代码.
---- 

*描述*

根据一个值在多个选择中选取要包含的一个代码区块，包含了的区块也会被传递给预处理器。

*例*

----
Red []

#do [level: 2]

print #case [
    level = 1  ["Easy"]
    level >= 2 ["Medium"]
    level >= 4 ["Hard"]
]
----  

结果将为：

----
Red []

print "Medium"
----

=== #include 

*语法*
----
#include <file>

<file> : 要包含的 Red 文件 (file!).
----  

*描述*

在编译时被执行时，读取并将参数文件内容包含在当前位置。该文件可以包含对于当前脚本绝对或相对的路径。当被 Red 解释器运行时，该指令只是被替换为一个 `do`，不会包含文件。

=== #do 

*语法*

----
#do [<body>]
#do keep [<body>]

<body> : 任意 Red 代码.
----

*描述*

在隐藏的语境中执行区块体。如果使用了 `keep`，则将指令和参数替换为 `body` 执行的结果。

*例*

----
Red []

#do [a: 1]

print ["2 + 3 =" #do keep [2 + 3]]
    
#if a < 0 [print "negative"]
----    

结果将为：

----
Red []

print ["2 + 3 =" 5]
----

=== #macro

*语法*
----
#macro <name> func <spec> <body>
#macro <pattern> func <spec> <body>

<name>    : name of the macro function (set-word!).
<pattern> : matching rule for triggering the macro (block!, word!, lit-word!).
<spec>    : specification block for the macro function.
<body>    : body block of the macro function.
----

*描述*

创建一个宏函数。

对于命名宏，指定的block可以根据需要声明任意数量的参数。body需要返回一个用于替换宏调用及其参数的值。 返回空块将仅删除宏调用及其参数。

对于模式匹配宏，spec块必须只声明**两个**参数，匹配模式的起始引用和结束引用。按照惯例，参数名称为：`func [start end]`或`func [s e]`作为短格式。 默认情况下，主体需要返回一个用于替换匹配模式的值。 返回一个空块将只是删除匹配的模式。

*手动*模式也可用于模式匹配宏。 可以通过在函数* spec *块中放置一个`[manual]`属性来设置：`func [[manual] start end]`。这种手动模式需要宏返回恢复位置(而不是替换值)。如果需要*重新处理*一个替换的模式，那么`start`是要返回的值。 如果需要*跳过匹配的模式，那么`end`是要返回的值。还可以返回其他位置，这取决于宏实现的转换，以及部分或全部重新处理替换值的愿望。

模式匹配宏接受：

* block: 使用Parse方言指定要匹配的模式。
* word: 指定一个有效的Parse方言word(如数据类型名称，或“skip”匹配所有值)。
* lit-word: 指定一个特定的文字来匹配。

*例子*
----
Red []
#macro pow2: func [n][to integer! n ** 2]
print pow2 10
print pow2 3 + pow2 4 = pow2 5
----
将会输出：
----
Red []
print 100
print 9 + 16 = 25
----   
模式匹配宏例子：
----
Red []
#macro [number! '+ number! '= number!] func [s e][
    do copy/part s e
]

print 9 + 16 = 25
----
将会输出：
----
Red []
print true
----
手动模式的模式匹配宏：
----
Red []
#macro ['sqrt number!] func [[manual] s e][
    if negative? s/2 [
        print [
            "*** SQRT Error: no negative number allowed" lf
            "*** At:" copy/part s e
        ]
        halt
    ]
    e             ;-- returns position passed the matched pattern
]

print sqrt 9
print sqrt -4
----
将会输出：
----
*** SQRT Error: no negative number allowed 
*** At: sqrt -4
(halted)
----

=== #local 

*语法*
----
#local [<body>]

<body> : arbitrary Red code containing local macros definitions.
----    
*描述*

为宏创建本地上下文。 在该上下文中定义的所有宏将在退出时被丢弃。 因此，本地宏也需要在本地应用。 这个指令可以递归使用（`＃local`是`<body>`中的一个有效的指令）。

*例子*
----
Red []
print 1.0
#local [
    #macro float! func [s e][to integer! s/1]
    print [1.23 2.54 123.789]
]
print 2.0
----
将会输出：
----
Red []
print 1.0
print [1 3 124]
print 2.0
----
=== #reset 

*语法*
----
#reset
---- 
*描述*

重置隐藏的上下文，将其从所有以前定义的单词中清空，并删除所有以前定义的宏。

=== #process

*语法*
----
#process [on | off]
---- 
*描述*

启用或禁用预处理器（默认情况下启用）。 这是一个避免处理Red文件的部分的转义机制，其中使用了指令，而不是用于预处理器（例如，如果在具有不同含义的方言中使用）。

实现约束：在禁用它之前再次启用预处理器时，`#process off`指令需要在代码中嵌套相同（或更高）的级别。

*例子*
----
Red []

print "Conditional directives:"
#process off
foreach d [#if #either #switch #case][probe d]
#process on
----    
将会输出：
----
Red []

print "Conditional directives:"
foreach d [#if #either #switch #case][probe d]
----
=== #trace 

*语法*
----
#trace [on | off]
----  
*描述*

启用或禁用屏幕上评估的表达式和宏的调试输出。 在Red源中可以使用该指令的方式没有特别的限制。


== 运行时API anchor:runtime-api[]

Red预处理器也可以在运行时工作，以便能够使用解释器中的预处理器指令来评估源代码。 在`file``值上使用`do`时会自动调用它。 请注意，以下形式可用于在不调用预处理程序的情况下执行文件：`do load％file`。

=== expand-directives 

*语法*
----
expand-directives [<body>]
expand-directives/clean [<body>]

<body> : arbitrary Red code containing preprocessor directives.
----
*描述*

对块值调用预处理器。 参数块将被修改并用作返回值。 如果使用`/ clean`细化，则预处理器状态被重置，所以先前定义的所有宏被擦除。

*例子*
----
expand-directives [print #either config/OS = 'Windows ["Windows"]["Unix"]]
----
Windows平台上会输出：
----
[print "Windows"]
----