= 编码样式指南
:toc:
:numbered:

== 介绍 

Red是一种同像语言，代码可以被视为数据。 该功能的结果是语言几乎是完全自由的，以便应对所有可能的方式来格式化数据，以及足够灵活的 DSL 特定格式化需求。 以下内容只是格式化 Red 代码的 _许多方法之一_。

本文档描述了 _Red 源代码中使用的官方编码风格_，因此，尊重此编码风格是提交给 Red/Red Github 资源库的每个提取请求的先决条件。

由于 Red/System 是 Red 的一种方言，它们共享相同的语法和编码风格规则。 特定的 Red/System 规则被标记为这样。

以下规则的目标是最大限度地提高可读性，包括在屏幕上保持最佳数量的代码行可见，同时最大限度地减少对注释的需求。

== 代码行长度 

对于单行代码，没有严格定义的最大列数，因为它可以根据使用的字体类型（大小，比例或固定宽度）或突出显示效果而有所不同。 应该可以在最多 1080p 监视器宽度的编辑器中读取全部代码（不包括注释）。 在我们用于 Red 代码库编码的显示器上，它大约是 100 列。 在下面的描述中，_表达式尺寸_ 或 _太长的_ 表达式将会不符合上述标准的代码行大小。

== 缩进 

Red 代码库使用大小为 *4* 列的列表符缩进源代码。 这给出了太小的值（如 2 列）和太大值（如 8 列）之间的良好折衷。 使用制表符也意味着您可以在编辑器中将其调整为您的个人偏好，同时遵守规则（只需使用制表符注意正确的对齐方式）。

所有贡献的 Red 文件到 Red/Red 代码仓库应该在其标题中包含以下字段：

 制表符: 4

每次打开一个块或圆括号后，你都要去新行，你应该在一个选项卡上缩进。

*正确*
----
 func [
     arg1
     arg2
     ...
 ][
     print arg1
     ...
 ]
----
不正确
---- 
 func [
 arg1				;-- 缺少缩进！
 arg2
 ...
 ][
		print arg1		;-- 过度缩进！
		...
 ]
----

== 块布局 

所有以下规则适用于块 `[]` 以及括号 `（）` 。

空块不包含任何空格：
 
 a: []
 
相邻的块在一个的结尾和另一个的开始之间不需要空格：
 
 [][]
 []()

 [
    你好
 ][						;-- 不需要间距
	   世界
 ]
 
然而，可以在嵌套块之间使用空格：
----
 array: [[] [] [] []]
 list:  [ [] [] [] [] ]

 either a = 1 [["你好"]][["世界"]]
 either a = 1 [ ["你好"] ][ ["世界"] ]
----

对于包含小块的表达式，它们通常在同一行上打开和关闭
 
 b: either a = 1 [a + 1][3]
 

如果行太长，则该块应该用一个级别的缩进包裹在几行上：

*正确*
----
 b: either a = 1 [
     a + 1
 ][
     123 + length? mold a
 ]
----

不正确
----
 b: either a = 1 
     [a + 1][123 + length? mold a]
----
_这种风格是错误的，因为它破坏了将代码复制/粘贴到 Red 控制台的能力（`同样` 将在检测到块参数之前进行评估）._

如果第一个块足够小并且可以适合同一行，则只有后续的块被包裹在几行中：
----
 print either a = 1 ["hello"][
     append mold a "这是一个很长的表达式"
 ]

 while [not tail? series][
     print series/1
     series: next series
 ]
----

== 命名约定 

*变量名* 应为单字 *名词* 。 选择简短的词语，尽可能地符合用意。 应该首先使用常用的单词（_特别是如果它们已经在现有 Red 源代码的同一上下文语境中使用过_）。 如果需要，请使用 http://www.thesaurus.com/browse/synonym[synonyms dictionary]v，找到能使用的最好的单词。 应尽可能避免单字母或缩写词（除非缩写词常用）。

由多个单词组成的名称用短划线 `-` 字符分隔。 只有在找不到合适的单词时或者与已经使用的单词混淆才会使用双字的名称。 由两个以上的单词组成的变量名称只能在极少数情况下使用。 尽可能多地使用单个词让代码水平方向更加紧凑，大大提高可读性。 避免无用的冗长。

*正确*
----
 code: 123456
 name: "John"
 table: [2 6 8 4 3]
 lost-items: []

 unless tail? list [author: select list index]
----

不正确
----
 code_for_article: 123456
 Mytable: [2 6 8 4 3]
 lostItems: []

 unless tail? list-of-books [author-property: select list-of-books selected-index]
----

*Function names* should strive to be single-word _verbs_, in order to express an action, though two or three words names are often necessary. More than three words should be avoided as much as possible. Variable naming conventions also apply to function names. A noun or an adjective followed by a question mark is also accepted. Often, it denotes that the return value is of `logic!` type, but this is not a strict rule, as it is handy to form single-word action names for retrieving a property (e.g. `length?`, `index?`). When forming function names with two or more words, always put the verb in the first position. If names are picked carefully for variables and function names, the code becomes almost self-documented, often reducing the need for comments.

*正确*
----
 make:   func [...
 reduce: func [...
 allow:  func [...
 crunch: func [...
----

不正确
----
 length:    func [...
 future:    func [...
 position:  func [...
 blue-fill: func [...		;-- should be fill-blue
----

There is an exception to those naming rules which applies to OS or non-Red third-party API names. In order to make API-specific function and structures field names easily recognizable, their original name should be used. It visually helps distinguish such imported names from regular Red or Red/System code. For example:

----
 tagMSG: alias struct! [
     hWnd   [handle!]
     msg    [integer!]
     wParam [integer!]
     lParam [integer!]
     time   [integer!]
     x      [integer!]
     y      [integer!]	
  ]

 #import [
    "User32.dll" stdcall [
        CreateWindowEx: "CreateWindowExW" [
            dwExStyle    [integer!]
            lpClassName  [c-string!]
            lpWindowName [c-string!]
            dwStyle      [integer!]
            x            [integer!]
            y            [integer!]
            nWidth       [integer!]
            nHeight      [integer!]
            hWndParent   [handle!]
            hMenu        [handle!]
            hInstance    [handle!]
            lpParam      [int-ptr!]
            return:      [handle!]
        ]
    ]
]
----

== Casing 

All variable and function names should be lowercase by default, unless there is a good reason for using uppercasing such as:

* name is an acronym e.g. GMT (Greenwich Mean Time)
* name is operating-system or (non-Red) third-party API-related

== Macros (Red/System) anchor:macros-redsystem[]

Apply the same naming conventions for picking up Red/System macros names. Macros generally use uppercase for names, as a way to visually distinguish them easily from the rest of the code (unless the intention is explicitely to make it look like regular code, like pseudo-custom datatype definitions). When multiple words are used, they are separated by an underscore `_` character to increase even more the difference with regular code.

_(TBD: extract all single-word names used in the Red codebase as examples)_

== Function definitions 

The general rule is to keep the spec block on a single line. The body block can be on the same line or over several lines. In case of Red/System, as the spec blocks tend to be longer, most functions spec blocks are wrapped over several lines, so, for sake of visual consistency, often even small spec block are wrapped.

*正确*
----
 do-nothing: func [][]
 increment: func [n [integer!]][n + 1]

 increment: func [n [integer!]][
    n + 1
 ]

 increment: func [
     n [integer!]
 ][
     n + 1
 ]
----
不正确
----
 do-nothing: func [
 ][
 ]

 do-nothing: func [

 ][

 ]

 increment: func [
     n [integer!]
 ][n + 1]
----

When the spec block is too long, it should be wrapped over several lines. When wrapping the spec block, each type definition must be on the same line as its argument. The optional attributes block should be on its own line. Each refinement starts on a new line. If followed by a single argument, the argument can be on the same line or a new line with an indentation (just be consistent with other refinements in the same spec block). For /local refinement, if the local words are not followed by type annotation, they can be put on the same line.

When wrapping the spec block over several lines, it is recommended to align the datatype definitions for consecutive arguments, on the same column for easier reading. Such alignment is preferably done using tabs (if you strictly follow these coding style rules) or else, using spaces.

*正确*
----
 make-world: func [
     earth	 [word!]
     wind 	 [bitset!]
     fire	 [binary!]
     water	 [string!]
     /with
         thunder [url!]
     /only
     /into
         space   [block! none!]
     /local
	 plants animals men women computers robots
 ][
     ...
 ]
----
不正确
----
 make-world: func [
  	[throw] earth [word!]		;-- attributes block not on its own line
    	wind	[bitset!]
    	fire [binary!]			;-- unaligned type definition
    	water	[string!]
    	/with
            thunder [url!]
    	/only
    	/into space [block! none!]	;-- inconsistent with /with formatting
    	/local
    	    plants animals		;-- breaking line too early
    	    men women computers robots
][
	...
]
----

For docstrings, the main one (describing the function) should be on its own line if the spec block is wrapped. The argument and refinement docstrings should be on the same line as the item they are describing. Docstrings start with a capital letter and do not require a ending dot (it's added automatically when printed on screen by `help` function).

*正确*
----
 increment: func ["Add 1 to the argument value" n][n + 1]

 make-world: func [
     "Build a new World"
     earth    [word!]      "1st element"
     wind     [bitset!]    "2nd element"
     fire     [binary!]    "3rd element"
     water    [string!]
     /with 		   "Additional element"
         thunder [url!]
     /only		   "Not implemented yet"
     /into		   "Provides a container"
         space [unset!]    "The container"
     /local
         plants animals men women computers robots
 ][
	...
 ]
----
不正确
----
 make-world: func ["Build a new World"	;-- should be on a newline
     earth	[word!]		"1st element"
     wind	[bitset!]	  "2nd element"	;-- excessive indentation
     fire	[binary!]
     "3rd element"			;-- should be on same line as `fire`
     water	[string!]
     /with 			"Additional element"
    		thunder [url!]
     /only "Not implemented yet"	;-- should be aligned with other docstrings
     /into
           "Provides a container"      ;-- should follow the refinement
    	    space [unset!]	"The container"
     /local
         plants animals men women computers robots
 ][
    	...
 ]
----

== Function calls 

Arguments are following the function call on the same line. If the line becomes too long, arguments can be wrapped over several lines (one argument per line) with an indentation.

*正确*
----
 foo arg1 arg2 arg3 arg4 arg5

 process-many
     argument1
     argument2
     argument3
     argument4
     argument5
----
不正确
----
 foo arg1 arg2 arg3
     arg4 arg5

 foo
     arg1 arg2 arg3
     arg4 arg5

 process-many
     argument1
         argument2
             argument3
                 argument4
                     argument5
----

For long expressions with many nested parts, spotting the bounds of each expression can be sometimes difficult. Using parenthesis for grouping a nested call with its arguments is acceptable (but not mandatory).
----
 head insert (copy/part [1 2 3 4] 2) (length? mold (2 + index? find "Hello" #"o"))

 head insert 
     copy/part [1 2 3 4] 2
     length? mold (2 + index? find "Hello" #"o")
----

== Comments 

In Red codebase:

* comments are written using the `;--` prefix (stronger visual clue)
* single-line comments start at column 57 (works best on average, else column 53)
* multi-line comments are done using several single-line prefixes rather than `comment {...}` constructions.

The general rule is to put comments on the same line as the beginning of the corresponding code instead of on a new line in order to save significant vertical space. Though, if the comment is used for separating chunks of code, then putting it on a new line is fine.

== String syntax 

Use `""` for single-line strings. The `{}` form is reserved for multi-line strings. Respecting this rule ensures:

* a more consistent source representation before and after LOADing code
* better convey of meaning

One exception to the rule is when a single-line string includes the " character itself. In this case, it is preferred to use the `{}` form rather than escaping the quote `^"` as it is more readable.

== New line usage 

TBD